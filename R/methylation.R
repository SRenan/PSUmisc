# - Function to get results from bismatk
# - Function to annotate the reads


#' Process methylation data from bismark
#'
#' Read output from bismark and return methylation states for all reads/positions.
#'
#' @param prefix A \code{character}. The prefix for all file.
#' @param path A \code{character}. The path with the bam files generated by
#'  \code{bismark}.
#'
#' @return  A \code{data.table} with one row per position per read and methylation
#' state.
#' @export
bismark_results <- function(prefix, path = "."){
  lf <- list.files(path = path, pattern = prefix)
  cpg_obf <- grep("cpg_ob", lf, value = t)
  cpg_otf <- grep("cpg_ot", lf, value = t)
  if(length(cpg_obf) != 1 | length(cpg_otf) != 1){
    lobf <- length(cpg_obf)
    lotf <- length(cpg_otf)
    stop(paste0("You should have exactly 1 ob file and 1 ot file. you have ", lobf, " and ", lotf, "."))
  }
  cpg_ob <- fread(cpg_obf, header = f)
  cpg_ot <- fread(cpg_otf, header = f)
  cpg_ob[, Mstrand := "ob"]
  cpg_ot[, Mstrand := "ot"]
  cpg <- rbind(cpg_ob, cpg_ot)
  setnames(cpg, c("id", "meth_state", "chr", "pos", "meth_call", "strand"))
  return(cpg)
}


# Output should be: srr, strand, read_id, pos, meth
#' Filter bismark cpg files
#'
#' Filter bismark results to retain columns useful for further analysis and
#' keep chromosome of interest.
#'
#' @importFrom tools file_path_sans_ext
#' @return  A \code{data.table} of methylation status with one row per read.
#' @export
filter_bm_extract <- function(file, chrom = "X"){
  dat <- fread(file, header = FALSE)
  setnames(dat, c("read_id", "meth_status", "chr", "pos", "meth_call"))
  if(chrom & !is.na(chrom)){
    dat <- dat[chr == chrom]
  }
  fn <- basename(file_path_sans_ext(file))
  fs <- substr(sub("CpG_O", "", fn), 0, 1)
  dat[, file := fn]
  dat[, strand := fs]
  ret <- dat[, .(file, strand, read_id, pos, meth_status)]
  return(ret)
}

#' Read bismark summary
#'
#' Read and cleanup summary from bismark2summary
#'
#' @param summary A \code{character} summary file name.
#' @export
read_bm_summary <- function(summary){
  sry <- fread(summary)
  setnames(sry, chartr(" ", "_", tolower(names(sry))))
  ret <- sry[, .(file, total_reads,
             align_rate = round(100*aligned_reads/total_reads, 2),
             total_cs,
             cpg_meth_rate = round(100*methylated_cpgs/(methylated_cpgs + unmethylated_cpgs), 2))]
  return(ret)
}

#' Get a list of CpGs
#'
#' Get CpGs ranges from UCSC and matching genes.
#'
#' @param version A \code{character}. Must be 'hg38' for now.
#' @param chr A \code{character}. The chromosome to extract CpGs for
#' @param old_bioc A \code{logical}. This is needed on systems with Bioc 3.8,
#' where `seqnames(x) %in%` does returns an error. If set to TRUE, \code{chr}
#' must be of length 1.
#'
#' @importFrom GenomicRanges findOverlaps
#' @importFrom AnnotationHub AnnotationHub
#' @importFrom annotatr build_annotations
#' @export
get_cpg <- function(version = "hg38", chr = "chrX", old_bioc = FALSE){
  annoc <- build_annotations(genome = version, annotations = "hg38_cpgs")
  annog <- build_annotations(genome = version, annotations = "hg38_basicgenes")

  if(old_bioc){ #TODO: rm this when all systems are >Bioc3.10
    annoc <- annoc[seqnames(annoc) == chr,]
    annog <- annog[seqnames(annog) == chr,]
  } else{
    annoc <- annoc[seqnames(annoc) %in% chr,]
    annog <- annog[seqnames(annog) %in% chr,]
  }

  # gene overlap
  olap <- findOverlaps(annoc, annog, select = "first", )
  dtcpg <- data.table(as.data.frame(annoc))
  dtgns <- data.table(as.data.frame(annog))
  dtcpg[, gene := dtgns[olap, symbol]]
  # limiting to promoters.
  annop <- annog[annog$type == "hg38_genes_promoters",]
  promolap <- findOverlaps(annoc, annop, select = "first")
  dtcpg[, promo := dtgns[promolap, symbol]]
  # limiting to exons
  annoex <- annog[annog$type == "hg38_genes_exons",]
  exolap <- findOverlaps(annoc, annoex, select = "first")
  dtcpg[, exon := dtgns[exolap, symbol]]
  # limiting to introns
  annoin <- annog[annog$type == "hg38_genes_introns",]
  introlap <- findOverlaps(annoc, annoin, select = "first")
  dtcpg[, intron := dtgns[introlap, symbol]]
  return(dtcpg)
}


# Deduplicate
# Take some bismark results and count the number of unique read positions (start/end combinations).
dedup <- function(bismark_cpgs){
  #
  bismark_cpgs[, meth_value := ifelse(meth_status == "+", 1, 0)]
  bismark_cpgs[, read_start := min(pos), by = "read_id"]
  bismark_cpgs[, read_end := max(pos), by = "read_id"]
  #
  bismark_cpgs[, read_site_id := setDT(list(rs = read_start, re = read_end, ge = gene))[, g := .GRP, by=c("rs", "re", "ge")]$g, by="sample"]
  bismark_cpgs[, read_site_count := .N, by = c("sample", "gene", "read_site_id")]
  bismark_cpgs[, pos_meth := mean(meth_value)]

}
